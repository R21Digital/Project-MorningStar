<!DOCTYPE html>
<html lang="en">
<head>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-Q4ZZ5SFJC0"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-Q4ZZ5SFJC0');
</script>
<!-- Fallback noscript version for privacy-aware users -->
<noscript>
  <iframe src="https://www.googletagmanager.com/ns.html?id=G-Q4ZZ5SFJC0"
          height="0" width="0" style="display:none;visibility:hidden"></iframe>
</noscript>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>My Sessions - SWGDB</title>
    <link rel="stylesheet" href="/css/swgdb-styles.css">
    <link rel="stylesheet" href="/css/session-viewer.css">
    <script src="https://unpkg.com/vue@3/dist/vue.global.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf-autotable/3.5.29/jspdf.plugin.autotable.min.js"></script>
</head>
<body>
    <div id="app">
        <!-- Header -->
        <header class="swgdb-header">
            <div class="header-content">
                <h1>My Sessions</h1>
                <p>View and analyze your bot session reports</p>
            </div>
        </header>

        <!-- Main Content -->
        <main class="session-viewer-main">
            <!-- Filters Section -->
            <section class="filters-section">
                <div class="filter-container">
                    <div class="filter-group">
                        <label for="character-filter">Character:</label>
                        <select id="character-filter" v-model="filters.character" @change="applyFilters">
                            <option value="">All Characters</option>
                            <option v-for="char in availableCharacters" :key="char" :value="char">
                                {{ char }}
                            </option>
                        </select>
                    </div>

                    <div class="filter-group">
                        <label for="planet-filter">Planet:</label>
                        <select id="planet-filter" v-model="filters.planet" @change="applyFilters">
                            <option value="">All Planets</option>
                            <option v-for="planet in availablePlanets" :key="planet" :value="planet">
                                {{ planet }}
                            </option>
                        </select>
                    </div>

                    <div class="filter-group">
                        <label for="profession-filter">Profession:</label>
                        <select id="profession-filter" v-model="filters.profession" @change="applyFilters">
                            <option value="">All Professions</option>
                            <option v-for="prof in availableProfessions" :key="prof" :value="prof">
                                {{ prof }}
                            </option>
                        </select>
                    </div>

                    <div class="filter-group">
                        <label for="date-filter">Date Range:</label>
                        <input type="date" id="date-filter" v-model="filters.startDate" @change="applyFilters">
                        <span>to</span>
                        <input type="date" v-model="filters.endDate" @change="applyFilters">
                    </div>

                    <div class="filter-group">
                        <button class="btn btn-secondary" @click="clearFilters">Clear Filters</button>
                        <button class="btn btn-primary" @click="refreshSessions">Refresh</button>
                    </div>
                </div>
            </section>

            <!-- Statistics Section -->
            <section class="stats-section" v-if="filteredSessions.length > 0">
                <div class="stats-grid">
                    <div class="stat-card">
                        <h3>Total Sessions</h3>
                        <p class="stat-number">{{ filteredSessions.length }}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total XP Gained</h3>
                        <p class="stat-number">{{ formatNumber(totalStats.xpGained) }}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total Credits</h3>
                        <p class="stat-number">{{ formatNumber(totalStats.creditsGained) }}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total Quests</h3>
                        <p class="stat-number">{{ totalStats.questsCompleted }}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Total Time</h3>
                        <p class="stat-number">{{ formatDuration(totalStats.totalTime) }}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Stuck Events</h3>
                        <p class="stat-number">{{ totalStats.stuckEvents }}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Whisper Alerts</h3>
                        <p class="stat-number">{{ totalStats.whisperAlerts }}</p>
                    </div>
                    <div class="stat-card">
                        <h3>Avg XP/Hour</h3>
                        <p class="stat-number">{{ Math.round(totalStats.avgXpPerHour) }}</p>
                    </div>
                </div>
            </section>

            <!-- Charts Section -->
            <section class="charts-section" v-if="filteredSessions.length > 0">
                <div class="chart-container">
                    <div class="chart-card">
                        <h3>XP by Profession</h3>
                        <canvas id="xpChart" width="400" height="200"></canvas>
                    </div>
                    <div class="chart-card">
                        <h3>Credits by Source</h3>
                        <canvas id="creditsChart" width="400" height="200"></canvas>
                    </div>
                    <div class="chart-card">
                        <h3>Quests by Planet</h3>
                        <canvas id="questsChart" width="400" height="200"></canvas>
                    </div>
                    <div class="chart-card">
                        <h3>Session Duration Distribution</h3>
                        <canvas id="durationChart" width="400" height="200"></canvas>
                    </div>
                </div>
            </section>

            <!-- Quest Breakdown Section -->
            <section class="quest-breakdown-section" v-if="filteredSessions.length > 0">
                <div class="section-header">
                    <h2>Quest Breakdown</h2>
                    <div class="section-actions">
                        <button class="btn btn-secondary" @click="exportQuestReport">Export Quest Report</button>
                    </div>
                </div>
                <div class="quest-breakdown-grid">
                    <div class="quest-breakdown-card">
                        <h3>Quest Types</h3>
                        <div class="quest-type-list">
                            <div v-for="(count, type) in questTypeBreakdown" :key="type" class="quest-type-item">
                                <span class="quest-type-name">{{ type }}</span>
                                <span class="quest-type-count">{{ count }}</span>
                                <span class="quest-type-percentage">{{ Math.round((count / totalStats.questsCompleted) * 100) }}%</span>
                            </div>
                        </div>
                    </div>
                    <div class="quest-breakdown-card">
                        <h3>Top Quest Zones</h3>
                        <div class="quest-zone-list">
                            <div v-for="(count, zone) in questZoneBreakdown" :key="zone" class="quest-zone-item">
                                <span class="quest-zone-name">{{ zone }}</span>
                                <span class="quest-zone-count">{{ count }}</span>
                            </div>
                        </div>
                    </div>
                    <div class="quest-breakdown-card">
                        <h3>Reward Types</h3>
                        <div class="reward-type-list">
                            <div v-for="(count, type) in rewardTypeBreakdown" :key="type" class="reward-type-item">
                                <span class="reward-type-name">{{ type }}</span>
                                <span class="reward-type-count">{{ count }}</span>
                            </div>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Whisper Alerts Section -->
            <section class="whisper-alerts-section" v-if="totalStats.whisperAlerts > 0">
                <div class="section-header">
                    <h2>Whisper Alerts</h2>
                    <div class="section-actions">
                        <button class="btn btn-secondary" @click="exportWhisperReport">Export Alert Report</button>
                    </div>
                </div>
                <div class="whisper-alerts-list">
                    <div v-for="alert in whisperAlerts" :key="alert.timestamp" class="whisper-alert-item">
                        <div class="alert-header">
                            <span class="alert-sender">{{ alert.sender }}</span>
                            <span class="alert-time">{{ formatDateTime(alert.timestamp) }}</span>
                            <span class="alert-session">{{ alert.session_id }}</span>
                        </div>
                        <div class="alert-message">{{ alert.message }}</div>
                        <div class="alert-actions">
                            <span class="alert-response" v-if="alert.response_sent">✓ Responded</span>
                            <span class="alert-priority" :class="alert.priority">{{ alert.priority }}</span>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Sessions List -->
            <section class="sessions-section">
                <div class="sessions-header">
                    <h2>Sessions ({{ filteredSessions.length }})</h2>
                    <div class="session-actions">
                        <button class="btn btn-secondary" @click="exportAllSessions">Export All</button>
                        <button class="btn btn-primary" @click="generateReport">Generate Report</button>
                    </div>
                </div>

                <div class="sessions-grid" v-if="filteredSessions.length > 0">
                    <session-card
                        v-for="session in paginatedSessions"
                        :key="session.session_id"
                        :session="session"
                        @download="downloadSession"
                        @view="viewSessionDetails"
                    ></session-card>
                </div>

                <div class="no-sessions" v-else>
                    <p>No sessions found matching your filters.</p>
                    <button class="btn btn-primary" @click="clearFilters">Clear Filters</button>
                </div>

                <!-- Pagination -->
                <div class="pagination" v-if="totalPages > 1">
                    <button 
                        class="btn btn-secondary" 
                        :disabled="currentPage === 1"
                        @click="currentPage--"
                    >
                        Previous
                    </button>
                    <span class="page-info">
                        Page {{ currentPage }} of {{ totalPages }}
                    </span>
                    <button 
                        class="btn btn-secondary" 
                        :disabled="currentPage === totalPages"
                        @click="currentPage++"
                    >
                        Next
                    </button>
                </div>
            </section>
        </main>

        <!-- Session Details Modal -->
        <div class="modal-overlay" v-if="showSessionModal" @click="closeSessionModal">
            <div class="modal-content" @click.stop>
                <div class="modal-header">
                    <h2>Session Details</h2>
                    <button class="modal-close" @click="closeSessionModal">&times;</button>
                </div>
                <div class="modal-body" v-if="selectedSession">
                    <div class="session-details">
                        <div class="detail-section">
                            <h3>Basic Information</h3>
                            <div class="detail-grid">
                                <div class="detail-item">
                                    <label>Session ID:</label>
                                    <span>{{ selectedSession.session_id }}</span>
                                </div>
                                <div class="detail-item">
                                    <label>Character:</label>
                                    <span>{{ selectedSession.character_name }}</span>
                                </div>
                                <div class="detail-item">
                                    <label>Start Time:</label>
                                    <span>{{ formatDateTime(selectedSession.start_time) }}</span>
                                </div>
                                <div class="detail-item">
                                    <label>End Time:</label>
                                    <span>{{ formatDateTime(selectedSession.end_time) }}</span>
                                </div>
                                <div class="detail-item">
                                    <label>Duration:</label>
                                    <span>{{ formatDuration(selectedSession.duration_minutes) }}</span>
                                </div>
                            </div>
                        </div>

                        <div class="detail-section">
                            <h3>Performance Metrics</h3>
                            <div class="metrics-grid">
                                <div class="metric-item">
                                    <label>XP Gained:</label>
                                    <span>{{ formatNumber(selectedSession.xp_data.total_xp_gained) }}</span>
                                </div>
                                <div class="metric-item">
                                    <label>Credits Gained:</label>
                                    <span>{{ formatNumber(selectedSession.credit_data.total_credits_gained) }}</span>
                                </div>
                                <div class="metric-item">
                                    <label>Quests Completed:</label>
                                    <span>{{ selectedSession.quest_data.total_quests_completed }}</span>
                                </div>
                                <div class="metric-item">
                                    <label>Locations Visited:</label>
                                    <span>{{ selectedSession.location_data.total_locations_visited }}</span>
                                </div>
                            </div>
                        </div>

                        <div class="detail-section" v-if="selectedSession.quest_data.quest_events.length > 0">
                            <h3>Quests Completed</h3>
                            <div class="quest-list">
                                <div 
                                    v-for="quest in selectedSession.quest_data.quest_events" 
                                    :key="quest.timestamp"
                                    class="quest-item"
                                >
                                    <span class="quest-name">{{ quest.quest_name }}</span>
                                    <span class="quest-time">{{ formatDateTime(quest.timestamp) }}</span>
                                    <span class="quest-zone" v-if="quest.zone">{{ quest.zone }}</span>
                                </div>
                            </div>
                        </div>

                        <div class="detail-section" v-if="selectedSession.location_data.location_events.length > 0">
                            <h3>Locations Visited</h3>
                            <div class="location-list">
                                <div 
                                    v-for="location in selectedSession.location_data.location_events" 
                                    :key="location.timestamp"
                                    class="location-item"
                                >
                                    <span class="location-name">{{ location.city }}, {{ location.planet }}</span>
                                    <span class="location-time">{{ formatDateTime(location.timestamp) }}</span>
                                    <span class="location-duration" v-if="location.duration_minutes">
                                        {{ formatDuration(location.duration_minutes) }}
                                    </span>
                                </div>
                            </div>
                        </div>

                        <div class="detail-section" v-if="selectedSession.event_data.stuck_events.length > 0">
                            <h3>Stuck Events</h3>
                            <div class="stuck-list">
                                <div 
                                    v-for="event in selectedSession.event_data.stuck_events" 
                                    :key="event.timestamp"
                                    class="stuck-item"
                                >
                                    <span class="stuck-location">{{ event.location }}</span>
                                    <span class="stuck-reason">{{ event.reason }}</span>
                                    <span class="stuck-duration">{{ formatDuration(event.duration_seconds / 60) }}</span>
                                </div>
                            </div>
                        </div>

                        <div class="detail-section" v-if="selectedSession.event_data.communication_events.length > 0">
                            <h3>Communication Events</h3>
                            <div class="communication-list">
                                <div 
                                    v-for="event in selectedSession.event_data.communication_events" 
                                    :key="event.timestamp"
                                    class="communication-item"
                                    :class="{ 'whisper-alert': event.event_type === 'whisper' }"
                                >
                                    <span class="comm-type">{{ event.event_type }}</span>
                                    <span class="comm-sender">{{ event.sender }}</span>
                                    <span class="comm-message">{{ event.message }}</span>
                                    <span class="comm-time">{{ formatDateTime(event.timestamp) }}</span>
                                    <span class="comm-response" v-if="event.response_sent">✓ Responded</span>
                                </div>
                            </div>
                        </div>

                        <div class="detail-section" v-if="selectedSession.event_data.guild_alerts.length > 0">
                            <h3>Guild Alerts</h3>
                            <div class="guild-alerts-list">
                                <div 
                                    v-for="alert in selectedSession.event_data.guild_alerts" 
                                    :key="alert.timestamp"
                                    class="guild-alert-item"
                                    :class="alert.priority"
                                >
                                    <div class="alert-header">
                                        <span class="alert-sender">{{ alert.sender }}</span>
                                        <span class="alert-type">{{ alert.alert_type }}</span>
                                        <span class="alert-priority">{{ alert.priority }}</span>
                                    </div>
                                    <div class="alert-message">{{ alert.message }}</div>
                                    <div class="alert-time">{{ formatDateTime(alert.timestamp) }}</div>
                                    <div class="alert-reply" v-if="alert.auto_reply_sent">
                                        <span class="reply-label">Auto Reply:</span>
                                        <span class="reply-message">{{ alert.reply_message }}</span>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <div class="detail-section" v-if="selectedSession.event_data.player_encounters.length > 0">
                            <h3>Player Encounters</h3>
                            <div class="player-encounters-list">
                                <div 
                                    v-for="encounter in selectedSession.event_data.player_encounters" 
                                    :key="encounter.timestamp"
                                    class="player-encounter-item"
                                >
                                    <span class="encounter-location">{{ encounter.location }}</span>
                                    <span class="encounter-type">{{ encounter.interaction_type }}</span>
                                    <span class="encounter-distance">{{ encounter.distance }}m</span>
                                    <span class="encounter-time">{{ formatDateTime(encounter.timestamp) }}</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-secondary" @click="downloadSession(selectedSession)">
                        Download JSON
                    </button>
                    <button class="btn btn-primary" @click="exportSessionPDF(selectedSession)">
                        Export PDF
                    </button>
                </div>
            </div>
        </div>

        <!-- Loading Overlay -->
        <div class="loading-overlay" v-if="loading">
            <div class="loading-spinner"></div>
            <p>Loading sessions...</p>
        </div>
    </div>

    <!-- Scripts -->
    <script src="/js/session-viewer.js"></script>
    <script src="/js/session-card.js"></script>
    <script>
        // Initialize Vue app
        const { createApp } = Vue;
        
        createApp({
            data() {
                return {
                    sessions: [],
                    filteredSessions: [],
                    loading: false,
                    currentPage: 1,
                    itemsPerPage: 12,
                    filters: {
                        character: '',
                        planet: '',
                        profession: '',
                        startDate: '',
                        endDate: ''
                    },
                    showSessionModal: false,
                    selectedSession: null,
                    charts: {}
                };
            },
            computed: {
                availableCharacters() {
                    return [...new Set(this.sessions.map(s => s.character_name))];
                },
                availablePlanets() {
                    const planets = [];
                    this.sessions.forEach(session => {
                        session.location_data.location_events.forEach(location => {
                            planets.push(location.planet);
                        });
                    });
                    return [...new Set(planets)];
                },
                availableProfessions() {
                    const professions = [];
                    this.sessions.forEach(session => {
                        Object.keys(session.xp_data.profession_breakdown || {}).forEach(prof => {
                            professions.push(prof);
                        });
                    });
                    return [...new Set(professions)];
                },
                totalPages() {
                    return Math.ceil(this.filteredSessions.length / this.itemsPerPage);
                },
                paginatedSessions() {
                    const start = (this.currentPage - 1) * this.itemsPerPage;
                    const end = start + this.itemsPerPage;
                    return this.filteredSessions.slice(start, end);
                },
                totalStats() {
                    if (this.filteredSessions.length === 0) {
                        return {
                            xpGained: 0,
                            creditsGained: 0,
                            questsCompleted: 0,
                            totalTime: 0,
                            stuckEvents: 0,
                            whisperAlerts: 0,
                            avgXpPerHour: 0
                        };
                    }

                    return this.filteredSessions.reduce((stats, session) => {
                        stats.xpGained += session.xp_data.total_xp_gained || 0;
                        stats.creditsGained += session.credit_data.total_credits_gained || 0;
                        stats.questsCompleted += session.quest_data.total_quests_completed || 0;
                        stats.totalTime += session.duration_minutes || 0;
                        stats.stuckEvents += session.event_data.stuck_events.length || 0;
                        
                        // Count whisper alerts
                        const whisperEvents = session.event_data.communication_events.filter(
                            event => event.event_type === 'whisper'
                        );
                        stats.whisperAlerts += whisperEvents.length;
                        
                        return stats;
                    }, {
                        xpGained: 0,
                        creditsGained: 0,
                        questsCompleted: 0,
                        totalTime: 0,
                        stuckEvents: 0,
                        whisperAlerts: 0,
                        avgXpPerHour: 0
                    });
                },
                questTypeBreakdown() {
                    const breakdown = {};
                    this.filteredSessions.forEach(session => {
                        session.quest_data.quest_events.forEach(quest => {
                            const type = quest.quest_type || 'unknown';
                            breakdown[type] = (breakdown[type] || 0) + 1;
                        });
                    });
                    return breakdown;
                },
                questZoneBreakdown() {
                    const breakdown = {};
                    this.filteredSessions.forEach(session => {
                        session.quest_data.quest_events.forEach(quest => {
                            const zone = quest.zone || 'Unknown';
                            breakdown[zone] = (breakdown[zone] || 0) + 1;
                        });
                    });
                    // Sort by count and return top 10
                    return Object.fromEntries(
                        Object.entries(breakdown)
                            .sort(([,a], [,b]) => b - a)
                            .slice(0, 10)
                    );
                },
                rewardTypeBreakdown() {
                    const breakdown = {};
                    this.filteredSessions.forEach(session => {
                        session.quest_data.quest_events.forEach(quest => {
                            const type = quest.reward_type || 'unknown';
                            breakdown[type] = (breakdown[type] || 0) + 1;
                        });
                    });
                    return breakdown;
                },
                whisperAlerts() {
                    const alerts = [];
                    this.filteredSessions.forEach(session => {
                        session.event_data.communication_events.forEach(event => {
                            if (event.event_type === 'whisper') {
                                alerts.push({
                                    ...event,
                                    session_id: session.session_id,
                                    character_name: session.character_name
                                });
                            }
                        });
                    });
                    return alerts.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
                }
            },
            methods: {
                async loadSessions() {
                    this.loading = true;
                    try {
                        const response = await fetch('/api/get_sessions_by_user.py', {
                            method: 'GET',
                            headers: {
                                'Content-Type': 'application/json',
                                'Authorization': `Bearer ${this.getAuthToken()}`
                            }
                        });

                        if (response.ok) {
                            const data = await response.json();
                            this.sessions = data.sessions || [];
                            this.applyFilters();
                        } else {
                            console.error('Failed to load sessions');
                        }
                    } catch (error) {
                        console.error('Error loading sessions:', error);
                    } finally {
                        this.loading = false;
                    }
                },
                applyFilters() {
                    this.filteredSessions = this.sessions.filter(session => {
                        // Character filter
                        if (this.filters.character && session.character_name !== this.filters.character) {
                            return false;
                        }

                        // Planet filter
                        if (this.filters.planet) {
                            const hasPlanet = session.location_data.location_events.some(
                                location => location.planet === this.filters.planet
                            );
                            if (!hasPlanet) return false;
                        }

                        // Profession filter
                        if (this.filters.profession) {
                            const hasProfession = session.xp_data.profession_breakdown && 
                                session.xp_data.profession_breakdown[this.filters.profession];
                            if (!hasProfession) return false;
                        }

                        // Date filter
                        if (this.filters.startDate || this.filters.endDate) {
                            const sessionDate = new Date(session.start_time);
                            if (this.filters.startDate && sessionDate < new Date(this.filters.startDate)) {
                                return false;
                            }
                            if (this.filters.endDate && sessionDate > new Date(this.filters.endDate)) {
                                return false;
                            }
                        }

                        return true;
                    });

                    this.currentPage = 1;
                    this.updateCharts();
                },
                clearFilters() {
                    this.filters = {
                        character: '',
                        planet: '',
                        profession: '',
                        startDate: '',
                        endDate: ''
                    };
                    this.applyFilters();
                },
                refreshSessions() {
                    this.loadSessions();
                },
                viewSessionDetails(session) {
                    this.selectedSession = session;
                    this.showSessionModal = true;
                },
                closeSessionModal() {
                    this.showSessionModal = false;
                    this.selectedSession = null;
                },
                downloadSession(session) {
                    const dataStr = JSON.stringify(session, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `${session.session_id}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                },
                exportAllSessions() {
                    const dataStr = JSON.stringify(this.filteredSessions, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `all_sessions_${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                },
                async generateReport() {
                    // Implementation for generating comprehensive report
                    console.log('Generating report...');
                },
                exportQuestReport() {
                    const reportData = {
                        questTypeBreakdown: this.questTypeBreakdown,
                        questZoneBreakdown: this.questZoneBreakdown,
                        rewardTypeBreakdown: this.rewardTypeBreakdown,
                        totalQuests: this.totalStats.questsCompleted,
                        generatedAt: new Date().toISOString()
                    };
                    
                    const dataStr = JSON.stringify(reportData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `quest_report_${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                },
                exportWhisperReport() {
                    const reportData = {
                        whisperAlerts: this.whisperAlerts,
                        totalAlerts: this.totalStats.whisperAlerts,
                        generatedAt: new Date().toISOString()
                    };
                    
                    const dataStr = JSON.stringify(reportData, null, 2);
                    const dataBlob = new Blob([dataStr], { type: 'application/json' });
                    const url = URL.createObjectURL(dataBlob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = `whisper_alerts_${new Date().toISOString().split('T')[0]}.json`;
                    link.click();
                    URL.revokeObjectURL(url);
                },
                async exportSessionPDF(session) {
                    const { jsPDF } = window.jspdf;
                    const doc = new jsPDF();
                    
                    // Add title
                    doc.setFontSize(20);
                    doc.text('Session Report', 20, 20);
                    
                    // Add session details
                    doc.setFontSize(12);
                    doc.text(`Session ID: ${session.session_id}`, 20, 40);
                    doc.text(`Character: ${session.character_name}`, 20, 50);
                    doc.text(`Duration: ${this.formatDuration(session.duration_minutes)}`, 20, 60);
                    doc.text(`XP Gained: ${this.formatNumber(session.xp_data.total_xp_gained)}`, 20, 70);
                    doc.text(`Credits Gained: ${this.formatNumber(session.credit_data.total_credits_gained)}`, 20, 80);
                    doc.text(`Quests Completed: ${session.quest_data.total_quests_completed}`, 20, 90);
                    
                    // Add quests table
                    if (session.quest_data.quest_events.length > 0) {
                        doc.text('Quests Completed:', 20, 110);
                        const questData = session.quest_data.quest_events.map(q => [
                            q.quest_name,
                            this.formatDateTime(q.timestamp),
                            q.zone || 'N/A',
                            q.quest_type || 'N/A'
                        ]);
                        doc.autoTable({
                            startY: 115,
                            head: [['Quest', 'Time', 'Zone', 'Type']],
                            body: questData
                        });
                    }
                    
                    // Add stuck events
                    if (session.event_data.stuck_events.length > 0) {
                        doc.text('Stuck Events:', 20, doc.lastAutoTable.finalY + 20);
                        const stuckData = session.event_data.stuck_events.map(e => [
                            e.location,
                            e.reason,
                            `${Math.round(e.duration_seconds / 60)}m`
                        ]);
                        doc.autoTable({
                            startY: doc.lastAutoTable.finalY + 25,
                            head: [['Location', 'Reason', 'Duration']],
                            body: stuckData
                        });
                    }
                    
                    // Add whisper alerts
                    const whisperEvents = session.event_data.communication_events.filter(
                        e => e.event_type === 'whisper'
                    );
                    if (whisperEvents.length > 0) {
                        doc.text('Whisper Alerts:', 20, doc.lastAutoTable.finalY + 20);
                        const whisperData = whisperEvents.map(e => [
                            e.sender,
                            e.message.substring(0, 50) + (e.message.length > 50 ? '...' : ''),
                            this.formatDateTime(e.timestamp)
                        ]);
                        doc.autoTable({
                            startY: doc.lastAutoTable.finalY + 25,
                            head: [['Sender', 'Message', 'Time']],
                            body: whisperData
                        });
                    }
                    
                    doc.save(`${session.session_id}_report.pdf`);
                },
                updateCharts() {
                    this.$nextTick(() => {
                        this.createXPChart();
                        this.createCreditsChart();
                        this.createQuestsChart();
                        this.createDurationChart();
                    });
                },
                createXPChart() {
                    const ctx = document.getElementById('xpChart');
                    if (!ctx) return;

                    if (this.charts.xp) {
                        this.charts.xp.destroy();
                    }

                    const professionData = {};
                    this.filteredSessions.forEach(session => {
                        Object.entries(session.xp_data.profession_breakdown || {}).forEach(([prof, xp]) => {
                            professionData[prof] = (professionData[prof] || 0) + xp;
                        });
                    });

                    this.charts.xp = new Chart(ctx, {
                        type: 'doughnut',
                        data: {
                            labels: Object.keys(professionData),
                            datasets: [{
                                data: Object.values(professionData),
                                backgroundColor: [
                                    '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
                                    '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                },
                createCreditsChart() {
                    const ctx = document.getElementById('creditsChart');
                    if (!ctx) return;

                    if (this.charts.credits) {
                        this.charts.credits.destroy();
                    }

                    const sourceData = {};
                    this.filteredSessions.forEach(session => {
                        Object.entries(session.credit_data.credit_events || {}).forEach(([source, amount]) => {
                            sourceData[source] = (sourceData[source] || 0) + amount;
                        });
                    });

                    this.charts.credits = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: Object.keys(sourceData),
                            datasets: [{
                                label: 'Credits',
                                data: Object.values(sourceData),
                                backgroundColor: '#36A2EB'
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            }
                        }
                    });
                },
                createQuestsChart() {
                    const ctx = document.getElementById('questsChart');
                    if (!ctx) return;

                    if (this.charts.quests) {
                        this.charts.quests.destroy();
                    }

                    const planetData = {};
                    this.filteredSessions.forEach(session => {
                        session.quest_data.quest_events.forEach(quest => {
                            const planet = quest.zone || 'Unknown';
                            planetData[planet] = (planetData[planet] || 0) + 1;
                        });
                    });

                    this.charts.quests = new Chart(ctx, {
                        type: 'pie',
                        data: {
                            labels: Object.keys(planetData),
                            datasets: [{
                                data: Object.values(planetData),
                                backgroundColor: [
                                    '#FF6384', '#36A2EB', '#FFCE56', '#4BC0C0',
                                    '#9966FF', '#FF9F40', '#FF6384', '#C9CBCF'
                                ]
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                legend: {
                                    position: 'bottom'
                                }
                            }
                        }
                    });
                },
                createDurationChart() {
                    const ctx = document.getElementById('durationChart');
                    if (!ctx) return;

                    if (this.charts.duration) {
                        this.charts.duration.destroy();
                    }

                    const durations = this.filteredSessions.map(s => s.duration_minutes);
                    const bins = [0, 30, 60, 90, 120, 150, 180, 210, 240];
                    const histogram = new Array(bins.length - 1).fill(0);

                    durations.forEach(duration => {
                        for (let i = 0; i < bins.length - 1; i++) {
                            if (duration >= bins[i] && duration < bins[i + 1]) {
                                histogram[i]++;
                                break;
                            }
                        }
                    });

                    const labels = bins.slice(0, -1).map((bin, i) => 
                        `${bin}-${bins[i + 1]} min`
                    );

                    this.charts.duration = new Chart(ctx, {
                        type: 'bar',
                        data: {
                            labels: labels,
                            datasets: [{
                                label: 'Sessions',
                                data: histogram,
                                backgroundColor: '#4BC0C0'
                            }]
                        },
                        options: {
                            responsive: true,
                            plugins: {
                                legend: {
                                    display: false
                                }
                            },
                            scales: {
                                y: {
                                    beginAtZero: true
                                }
                            }
                        }
                    });
                },
                formatNumber(num) {
                    return new Intl.NumberFormat().format(num);
                },
                formatDuration(minutes) {
                    const hours = Math.floor(minutes / 60);
                    const mins = Math.round(minutes % 60);
                    if (hours > 0) {
                        return `${hours}h ${mins}m`;
                    }
                    return `${mins}m`;
                },
                formatDateTime(dateString) {
                    return new Date(dateString).toLocaleString();
                },
                getAuthToken() {
                    // Get auth token from localStorage or cookies
                    return localStorage.getItem('swgdb_auth_token') || '';
                }
            },
            mounted() {
                this.loadSessions();
            }
        }).mount('#app');
    </script>
</body>
</html> 