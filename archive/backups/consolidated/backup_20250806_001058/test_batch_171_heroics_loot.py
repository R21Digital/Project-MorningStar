#!/usr/bin/env python3
"""
Batch 171 - Heroics Loot Table Tests
Comprehensive test suite for the heroics loot table functionality.
"""

import yaml
import json
import os
import sys
from pathlib import Path
from typing import Dict, List, Any, Optional
import unittest
from unittest.mock import patch, mock_open

class TestHeroicsLootTable(unittest.TestCase):
    """Test suite for heroics loot table functionality."""
    
    def setUp(self):
        """Set up test fixtures."""
        self.test_data_dir = Path("swgdb_site/data/loot")
        self.test_loot_file = self.test_data_dir / "heroics.yml"
        self.test_pages_dir = Path("swgdb_site/pages")
        self.test_templates_dir = Path("swgdb_site/templates")
        self.test_utils_dir = Path("swgdb_site/utils")
        
        # Sample test data
        self.sample_loot_data = {
            "metadata": {
                "description": "Test loot data",
                "version": "1.0",
                "total_heroics": 2,
                "total_bosses": 3,
                "total_loot_items": 6
            },
            "rarity_levels": {
                "common": {"color": "#9d9d9d", "drop_chance_range": [15, 35]},
                "uncommon": {"color": "#1eff00", "drop_chance_range": [8, 20]},
                "rare": {"color": "#0070dd", "drop_chance_range": [3, 12]},
                "epic": {"color": "#a335ee", "drop_chance_range": [1, 8]},
                "legendary": {"color": "#ff8000", "drop_chance_range": [0.5, 3]}
            },
            "loot_types": {
                "weapon": {"description": "Combat weapons", "icon": "fas fa-sword"},
                "armor": {"description": "Protective equipment", "icon": "fas fa-shield-alt"},
                "material": {"description": "Crafting materials", "icon": "fas fa-hammer"}
            },
            "heroics": {
                "test_heroic_1": {
                    "name": "Test Heroic 1",
                    "planet": "Test Planet",
                    "bosses": [
                        {
                            "name": "Test Boss 1",
                            "level": 80,
                            "loot": [
                                {
                                    "name": "Test Weapon",
                                    "type": "weapon",
                                    "rarity": "epic",
                                    "drop_chance": 5.0,
                                    "use_case": "Combat weapon",
                                    "image": "test_weapon.png",
                                    "stats": {"damage": "100-150"},
                                    "description": "A test weapon"
                                }
                            ]
                        }
                    ]
                },
                "test_heroic_2": {
                    "name": "Test Heroic 2",
                    "planet": "Test Planet 2",
                    "bosses": [
                        {
                            "name": "Test Boss 2",
                            "level": 85,
                            "loot": [
                                {
                                    "name": "Test Armor",
                                    "type": "armor",
                                    "rarity": "rare",
                                    "drop_chance": 10.0,
                                    "use_case": "Protective gear",
                                    "image": "test_armor.png",
                                    "stats": {"armor_rating": 50},
                                    "description": "Test armor piece"
                                }
                            ]
                        }
                    ]
                }
            },
            "profession_relevance": {
                "jedi": ["Test Weapon"],
                "bounty_hunter": ["Test Weapon"],
                "medic": ["Test Armor"]
            },
            "source_info": {
                "generator": "SWGDB",
                "version": "1.0",
                "attribution_text": "Generated by SWGDB"
            }
        }
    
    def test_file_structure_exists(self):
        """Test that required files and directories exist."""
        required_files = [
            self.test_loot_file,
            self.test_pages_dir / "heroics.11ty.js",
            self.test_templates_dir / "partials" / "lootTable.njk",
            self.test_utils_dir / "yaml_loader.js"
        ]
        
        for file_path in required_files:
            with self.subTest(file_path=file_path):
                self.assertTrue(file_path.exists(), f"Required file missing: {file_path}")
    
    def test_yaml_data_structure(self):
        """Test YAML data structure validation."""
        if not self.test_loot_file.exists():
            self.skipTest("Loot file not found")
        
        try:
            with open(self.test_loot_file, 'r', encoding='utf-8') as f:
                data = yaml.safe_load(f)
            
            # Test required sections
            required_sections = ['heroics', 'rarity_levels', 'loot_types']
            for section in required_sections:
                with self.subTest(section=section):
                    self.assertIn(section, data, f"Missing required section: {section}")
            
            # Test heroics structure
            heroics = data.get('heroics', {})
            self.assertIsInstance(heroics, dict, "Heroics should be a dictionary")
            
            for heroic_id, heroic in heroics.items():
                with self.subTest(heroic_id=heroic_id):
                    self.assertIn('name', heroic, f"Heroic {heroic_id} missing name")
                    self.assertIn('planet', heroic, f"Heroic {heroic_id} missing planet")
                    self.assertIn('bosses', heroic, f"Heroic {heroic_id} missing bosses")
                    self.assertIsInstance(heroic['bosses'], list, f"Heroic {heroic_id} bosses should be list")
                    
                    for boss in heroic['bosses']:
                        self.assertIn('name', boss, "Boss missing name")
                        self.assertIn('level', boss, "Boss missing level")
                        self.assertIn('loot', boss, "Boss missing loot")
                        self.assertIsInstance(boss['loot'], list, "Boss loot should be list")
                        
                        for item in boss['loot']:
                            self.assertIn('name', item, "Loot item missing name")
                            self.assertIn('type', item, "Loot item missing type")
                            self.assertIn('rarity', item, "Loot item missing rarity")
                            self.assertIn('drop_chance', item, "Loot item missing drop_chance")
                            self.assertIn('use_case', item, "Loot item missing use_case")
                            self.assertIn('description', item, "Loot item missing description")
        
        except yaml.YAMLError as e:
            self.fail(f"YAML parsing error: {e}")
    
    def test_rarity_levels_validation(self):
        """Test rarity levels structure."""
        if not self.test_loot_file.exists():
            self.skipTest("Loot file not found")
        
        with open(self.test_loot_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        
        rarity_levels = data.get('rarity_levels', {})
        expected_rarities = ['common', 'uncommon', 'rare', 'epic', 'legendary']
        
        for rarity in expected_rarities:
            with self.subTest(rarity=rarity):
                self.assertIn(rarity, rarity_levels, f"Missing rarity level: {rarity}")
                rarity_data = rarity_levels[rarity]
                self.assertIn('color', rarity_data, f"Rarity {rarity} missing color")
                self.assertIn('drop_chance_range', rarity_data, f"Rarity {rarity} missing drop_chance_range")
    
    def test_loot_types_validation(self):
        """Test loot types structure."""
        if not self.test_loot_file.exists():
            self.skipTest("Loot file not found")
        
        with open(self.test_loot_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        
        loot_types = data.get('loot_types', {})
        expected_types = ['weapon', 'armor', 'accessory', 'consumable', 'material', 'cosmetic', 'currency', 'quest_item']
        
        for item_type in expected_types:
            with self.subTest(item_type=item_type):
                self.assertIn(item_type, loot_types, f"Missing loot type: {item_type}")
                type_data = loot_types[item_type]
                self.assertIn('description', type_data, f"Loot type {item_type} missing description")
                self.assertIn('icon', type_data, f"Loot type {item_type} missing icon")
    
    def test_profession_relevance_validation(self):
        """Test profession relevance structure."""
        if not self.test_loot_file.exists():
            self.skipTest("Loot file not found")
        
        with open(self.test_loot_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        
        profession_relevance = data.get('profession_relevance', {})
        expected_professions = ['jedi', 'bounty_hunter', 'commando', 'medic', 'entertainer', 'trader', 'artisan', 'spy']
        
        for profession in expected_professions:
            with self.subTest(profession=profession):
                self.assertIn(profession, profession_relevance, f"Missing profession: {profession}")
                self.assertIsInstance(profession_relevance[profession], list, f"Profession {profession} should be list")
    
    def test_source_attribution(self):
        """Test source attribution is present."""
        if not self.test_loot_file.exists():
            self.skipTest("Loot file not found")
        
        with open(self.test_loot_file, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        
        source_info = data.get('source_info', {})
        self.assertIn('generator', source_info, "Missing generator in source_info")
        self.assertEqual(source_info['generator'], 'SWGDB', "Generator should be SWGDB")
        self.assertIn('attribution_text', source_info, "Missing attribution_text")
        self.assertEqual(source_info['attribution_text'], 'Generated by SWGDB', "Attribution text should be 'Generated by SWGDB'")
    
    def test_11ty_page_structure(self):
        """Test 11ty.js page structure."""
        page_file = self.test_pages_dir / "heroics.11ty.js"
        if not page_file.exists():
            self.skipTest("11ty page file not found")
        
        with open(page_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Test required components (updated for optimized version)
        required_components = [
            'loadAllLootData',
            'validateLootData', 
            'getDefaultLootData',
            'renderLootSections',
            'filterLootData',
            'applyFilters'
        ]
        
        for component in required_components:
            with self.subTest(component=component):
                self.assertIn(component, content, f"Missing component: {component}")
    
    def test_nunjucks_template_structure(self):
        """Test Nunjucks template structure."""
        template_file = self.test_templates_dir / "partials" / "lootTable.njk"
        if not template_file.exists():
            self.skipTest("Nunjucks template file not found")
        
        with open(template_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Test required macros
        required_macros = [
            'renderLootItem',
            'renderBossSection',
            'renderHeroicSection',
            'renderFilters',
            'renderLootContainer',
            'renderSourceAttribution'
        ]
        
        for macro in required_macros:
            with self.subTest(macro=macro):
                self.assertIn(macro, content, f"Missing macro: {macro}")
    
    def test_yaml_loader_structure(self):
        """Test YAML loader utility structure."""
        loader_file = self.test_utils_dir / "yaml_loader.js"
        if not loader_file.exists():
            self.skipTest("YAML loader file not found")
        
        with open(loader_file, 'r', encoding='utf-8') as f:
            content = f.read()
        
        # Test required methods
        required_methods = [
            'loadYaml',
            'loadHeroicsLoot',
            'getHeroicsSection',
            'getAllHeroics',
            'getRarityLevels',
            'getLootTypes',
            'getProfessionRelevance',
            'validateHeroicsData',
            'getFilteredHeroics'
        ]
        
        for method in required_methods:
            with self.subTest(method=method):
                self.assertIn(method, content, f"Missing method: {method}")
    
    def test_filtering_functionality(self):
        """Test filtering functionality with sample data."""
        # Test filters
        test_filters = [
            {"heroic": "all", "rarity": "all", "type": "all", "profession": "all"},
            {"heroic": "test_heroic_1", "rarity": "all", "type": "all", "profession": "all"},
            {"heroic": "all", "rarity": "epic", "type": "all", "profession": "all"},
            {"heroic": "all", "rarity": "all", "type": "weapon", "profession": "all"},
            {"heroic": "all", "rarity": "all", "type": "all", "profession": "jedi"}
        ]
        
        for filters in test_filters:
            with self.subTest(filters=filters):
                filtered_data = self._apply_filters(self.sample_loot_data, filters)
                self.assertIsInstance(filtered_data, dict, "Filtered data should be dictionary")
    
    def _apply_filters(self, data, filters):
        """Helper method to apply filters to test data."""
        filtered = {}
        
        for heroic_id, heroic in data.get('heroics', {}).items():
            # Apply heroic filter
            if 'heroic' in filters and filters['heroic'] != 'all' and filters['heroic'] != heroic_id:
                continue
            
            # Apply planet filter
            if 'planet' in filters and filters['planet'] != 'all' and filters['planet'] != heroic.get('planet'):
                continue
            
            # Filter bosses and their loot
            filtered_bosses = []
            for boss in heroic.get('bosses', []):
                filtered_loot = []
                for item in boss.get('loot', []):
                    # Rarity filter
                    if 'rarity' in filters and filters['rarity'] != 'all' and item.get('rarity') != filters['rarity']:
                        continue
                    
                    # Type filter
                    if 'type' in filters and filters['type'] != 'all' and item.get('type') != filters['type']:
                        continue
                    
                    # Profession filter
                    if 'profession' in filters and filters['profession'] != 'all':
                        profession_items = data.get('profession_relevance', {}).get(filters['profession'], [])
                        if item.get('name') not in profession_items:
                            continue
                    
                    filtered_loot.append(item)
                
                if filtered_loot:
                    filtered_bosses.append({
                        **boss,
                        'loot': filtered_loot
                    })
            
            if filtered_bosses:
                filtered[heroic_id] = {
                    **heroic,
                    'bosses': filtered_bosses
                }
        
        return filtered
    
    def test_statistics_calculation(self):
        """Test statistics calculation functionality."""
        stats = self._calculate_statistics(self.sample_loot_data)
        
        expected_stats = {
            'total_heroics': 2,
            'total_bosses': 2,
            'total_loot_items': 2,
            'rarity_distribution': {'epic': 1, 'rare': 1},
            'type_distribution': {'weapon': 1, 'armor': 1}
        }
        
        for key, expected_value in expected_stats.items():
            with self.subTest(key=key):
                self.assertEqual(stats.get(key), expected_value, f"Statistics mismatch for {key}")
    
    def _calculate_statistics(self, data):
        """Helper method to calculate statistics from test data."""
        stats = {
            "total_heroics": len(data.get('heroics', {})),
            "total_bosses": 0,
            "total_loot_items": 0,
            "rarity_distribution": {},
            "type_distribution": {}
        }
        
        for heroic in data.get('heroics', {}).values():
            stats["total_bosses"] += len(heroic.get('bosses', []))
            for boss in heroic.get('bosses', []):
                stats["total_loot_items"] += len(boss.get('loot', []))
                
                for item in boss.get('loot', []):
                    rarity = item.get('rarity', 'unknown')
                    item_type = item.get('type', 'unknown')
                    
                    stats["rarity_distribution"][rarity] = stats["rarity_distribution"].get(rarity, 0) + 1
                    stats["type_distribution"][item_type] = stats["type_distribution"].get(item_type, 0) + 1
        
        return stats
    
    def test_ui_features_validation(self):
        """Test UI features are properly implemented."""
        # Test CSS classes and styling
        expected_css_classes = [
            'rarity-common', 'rarity-uncommon', 'rarity-rare', 'rarity-epic', 'rarity-legendary',
            'loot-item', 'loot-header', 'loot-name', 'loot-rarity',
            'filter-btn', 'filter-btn.active', 'heroic-section', 'boss-section'
        ]
        
        # Test JavaScript functionality
        expected_js_functions = [
            'initializeFilters', 'applyFilters', 'filterLootData', 'renderLootSections'
        ]
        
        # Test HTML structure
        expected_html_elements = [
            'data-filter', 'data-value', 'id="lootContainer"', 'class="source-attribution"'
        ]
        
        # These would be tested in actual HTML/CSS/JS files
        # For now, we just verify the test structure
        self.assertTrue(len(expected_css_classes) > 0, "CSS classes should be defined")
        self.assertTrue(len(expected_js_functions) > 0, "JS functions should be defined")
        self.assertTrue(len(expected_html_elements) > 0, "HTML elements should be defined")

class TestHeroicsLootTableIntegration(unittest.TestCase):
    """Integration tests for heroics loot table functionality."""
    
    def test_end_to_end_data_flow(self):
        """Test complete data flow from YAML to UI."""
        # This would test the complete flow from data loading to UI rendering
        # For now, we test the basic structure
        test_data = {
            "heroics": {
                "test": {
                    "name": "Test Heroic",
                    "planet": "Test Planet",
                    "bosses": [{
                        "name": "Test Boss",
                        "level": 80,
                        "loot": [{
                            "name": "Test Item",
                            "type": "weapon",
                            "rarity": "epic",
                            "drop_chance": 5.0,
                            "use_case": "Test use",
                            "description": "Test description"
                        }]
                    }]
                }
            }
        }
        
        # Test data validation
        self.assertIn('heroics', test_data)
        self.assertIn('test', test_data['heroics'])
        self.assertIn('bosses', test_data['heroics']['test'])
        self.assertIn('loot', test_data['heroics']['test']['bosses'][0])
        
        # Test filtering
        filtered = self._filter_data(test_data, {"heroic": "test", "rarity": "epic"})
        self.assertIn('test', filtered)
        
        # Test statistics
        stats = self._calculate_stats(test_data)
        self.assertEqual(stats['total_heroics'], 1)
        self.assertEqual(stats['total_loot_items'], 1)
    
    def _filter_data(self, data, filters):
        """Helper method for filtering test data."""
        filtered = {}
        for heroic_id, heroic in data.get('heroics', {}).items():
            if 'heroic' in filters and filters['heroic'] != 'all' and filters['heroic'] != heroic_id:
                continue
            
            filtered_bosses = []
            for boss in heroic.get('bosses', []):
                filtered_loot = []
                for item in boss.get('loot', []):
                    if 'rarity' in filters and filters['rarity'] != 'all' and item.get('rarity') != filters['rarity']:
                        continue
                    filtered_loot.append(item)
                
                if filtered_loot:
                    filtered_bosses.append({**boss, 'loot': filtered_loot})
            
            if filtered_bosses:
                filtered[heroic_id] = {**heroic, 'bosses': filtered_bosses}
        
        return filtered
    
    def _calculate_stats(self, data):
        """Helper method for calculating test statistics."""
        stats = {
            'total_heroics': len(data.get('heroics', {})),
            'total_loot_items': 0
        }
        
        for heroic in data.get('heroics', {}).values():
            for boss in heroic.get('bosses', []):
                stats['total_loot_items'] += len(boss.get('loot', []))
        
        return stats

def run_tests():
    """Run all tests."""
    print("Running Batch 171 - Heroics Loot Table Tests")
    print("=" * 60)
    
    # Create test suite
    loader = unittest.TestLoader()
    suite = unittest.TestSuite()
    
    # Add test classes
    suite.addTests(loader.loadTestsFromTestCase(TestHeroicsLootTable))
    suite.addTests(loader.loadTestsFromTestCase(TestHeroicsLootTableIntegration))
    
    # Run tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(suite)
    
    # Print summary
    print("\nTest Summary:")
    print(f"Tests run: {result.testsRun}")
    print(f"Failures: {len(result.failures)}")
    print(f"Errors: {len(result.errors)}")
    print(f"Skipped: {len(result.skipped)}")
    
    if result.wasSuccessful():
        print("All tests passed!")
    else:
        print("Some tests failed!")
        if result.failures:
            print("\nFailures:")
            for test, traceback in result.failures:
                print(f"  - {test}: {traceback}")
        if result.errors:
            print("\nErrors:")
            for test, traceback in result.errors:
                print(f"  - {test}: {traceback}")
    
    return result.wasSuccessful()

if __name__ == "__main__":
    success = run_tests()
    sys.exit(0 if success else 1) 